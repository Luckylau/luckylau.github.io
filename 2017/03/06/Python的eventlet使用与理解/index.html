<!doctype html>



  


<html class="theme-next pisces use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>



<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />












  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.0" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="python," />








  <link rel="shortcut icon" type="image/x-icon" href="/logo.jpg?v=5.1.0" />






<meta name="description" content="neutron源码学习基础知识储备之Eventlet
eventlet在openstack，还有ryu控制器中使用频率很高，有必要总结一下用法。
什么是协程？​        说到Coroutine，我们必须提到两个更远的东西。在操作系统（os）级别，有进程（process）和线程（thread）两个（仅从我们常见的讲）实际的“东西”（不说概念是因为这两个家伙的确不仅仅是概念，而是实际存在的，os">
<meta property="og:type" content="article">
<meta property="og:title" content="Python的eventlet使用与理解">
<meta property="og:url" content="https://luckylau.github.io/2017/03/06/Python的eventlet使用与理解/index.html">
<meta property="og:site_name" content="Luckylau's Blog">
<meta property="og:description" content="neutron源码学习基础知识储备之Eventlet
eventlet在openstack，还有ryu控制器中使用频率很高，有必要总结一下用法。
什么是协程？​        说到Coroutine，我们必须提到两个更远的东西。在操作系统（os）级别，有进程（process）和线程（thread）两个（仅从我们常见的讲）实际的“东西”（不说概念是因为这两个家伙的确不仅仅是概念，而是实际存在的，os">
<meta property="og:image" content="https://luckylau.github.io/2017/03/06/Python的eventlet使用与理解/2.png">
<meta property="og:image" content="https://luckylau.github.io/2017/03/06/Python的eventlet使用与理解/1.png">
<meta property="og:updated_time" content="2017-03-06T13:56:02.837Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Python的eventlet使用与理解">
<meta name="twitter:description" content="neutron源码学习基础知识储备之Eventlet
eventlet在openstack，还有ryu控制器中使用频率很高，有必要总结一下用法。
什么是协程？​        说到Coroutine，我们必须提到两个更远的东西。在操作系统（os）级别，有进程（process）和线程（thread）两个（仅从我们常见的讲）实际的“东西”（不说概念是因为这两个家伙的确不仅仅是概念，而是实际存在的，os">
<meta name="twitter:image" content="https://luckylau.github.io/2017/03/06/Python的eventlet使用与理解/2.png">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    sidebar: {"position":"left","display":"post"},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="https://luckylau.github.io/2017/03/06/Python的eventlet使用与理解/"/>





  <title> Python的eventlet使用与理解 | Luckylau's Blog </title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  










  
  
    
  

  <div class="container one-collumn sidebar-position-left page-post-detail ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-meta ">
  

  <div class="custom-logo-site-title">
    <a href="/"  class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <span class="site-title">Luckylau's Blog</span>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>
    
      <p class="site-subtitle">Keep Moving, Keep Learning</p>
    
</div>

<div class="site-nav-toggle">
  <button>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
  </button>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            关于
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      

      
        <li class="menu-item menu-item-search">
          
            <a href="javascript:;" class="popup-trigger">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br />
            
            搜索
          </a>
        </li>
      
    </ul>
  

  
    <div class="site-search">
      
  <div class="popup">
 <span class="search-icon fa fa-search"></span>
 <input type="text" id="local-search-input">
 <div id="local-search-result"></div>
 <span class="popup-btn-close">close</span>
</div>


    </div>
  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
  <link itemprop="mainEntityOfPage" href="https://luckylau.github.io/2017/03/06/Python的eventlet使用与理解/">

  <span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="name" content="Luckylau">
    <meta itemprop="description" content="">
    <meta itemprop="image" content="/logo.jpg">
  </span>

  <span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="Luckylau's Blog">
    <span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject">
      <img style="display:none;" itemprop="url image" alt="Luckylau's Blog" src="">
    </span>
  </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                Python的eventlet使用与理解
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-03-06T15:50:55+08:00">
                2017-03-06
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Python/" itemprop="url" rel="index">
                    <span itemprop="name">Python</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          

          
          

          
            <span class="post-meta-divider">|</span>
            <span class="page-pv"><i class="fa fa-file-o"></i>
            <span class="busuanzi-value" id="busuanzi_value_page_pv" ></span>
            </span>
          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        <p><strong>neutron源码学习基础知识储备之Eventlet</strong></p>
<p>eventlet在openstack，还有ryu控制器中使用频率很高，有必要总结一下用法。</p>
<h3 id="什么是协程？"><a href="#什么是协程？" class="headerlink" title="什么是协程？"></a>什么是协程？</h3><p>​        说到Coroutine，我们必须提到两个更远的东西。在操作系统（os）级别，有进程（process）和线程（thread）两个（仅从我们常见的讲）实际的“东西”（不说概念是因为这两个家伙的确不仅仅是概念，而是实际存在的，os的代码管理的资源）。这两个东西都是用来模拟“并行”的，写操作系统的程序员通过用一定的策略给不同的进程和线程分配CPU计算资源，来让用户“以为”几个不同的事情在“同时”进行“。在单CPU上，是os代码强制把一个进程或者线程挂起，换成另外一个来计算，所以，实际上是串行的，只是“概念上的并行”。在现在的多核的cpu上，线程可能是“真正并行的”。</p>
<a id="more"></a>
<p>​        Coroutine，翻译成”协程“，初始碰到的人马上就会跟上面两个概念联系起来。直接先说区别，Coroutine是编译器级的，Process和Thread是操作系统级的。Coroutine的实现，通常是对某个语言做相应的提议，然后通过后成编译器标准，然后编译器厂商来实现该机制。Process和Thread看起来也在语言层次，但是内生原理却是操作系统先有这个东西，然后通过一定的API暴露给用户使用，两者在这里有不同。Process和Thread是os通过调度算法，保存当前的上下文，然后从上次暂停的地方再次开始计算，重新开始的地方不可预期，每次CPU计算的指令数量和代码跑过的CPU时间是相关的，跑到os分配的cpu时间到达后就会被os强制挂起。Coroutine是编译器的魔术，通过插入相关的代码使得代码段能够实现分段式的执行，重新开始的地方是yield关键字指定的，一次一定会跑到一个yield对应的地方。</p>
<p>总之，对于Coroutine，是编译器帮助做了很多的事情，来让代码不是一次性的跑到底，而不是操作系统强制的挂起。代码每次跑多少，是可预期的。但是，Process和Thread，在这个层面上完全不同，这两个东西是操作系统管理的。</p>
<h3 id="python-eventlet又是什么"><a href="#python-eventlet又是什么" class="headerlink" title="python-eventlet又是什么?"></a>python-eventlet又是什么?</h3><p>官方网站对eventlet的描述是：</p>
<p>​       Eventlet is built around the concept of green threads (i.e. coroutines, we use the terms interchangeably) that are launched to do network-related work. </p>
<p>Green threads differ from normal threads in two main ways:</p>
<p>​    Green threads are so cheap they are nearly free. You do not have to conserve green threads like you would normal threads. In general, there will be at least one green thread per network connection.<br>Green threads cooperatively yield to each other instead of preemptively being scheduled. The major advantage from this behavior is that shared data structures don’t need locks, because only if a yield is explicitly called can<br>​    another green thread have access to the data structure. It is also possible to inspect primitives such as queues to see if they have any pending data.</p>
<p>​       大概意思是Eventlet是以绿色线程（协同线程）的概念建立起来的网络库，绿色线程和普通线程的区别是：1.绿色线程的开销小 2.绿色线程共享数据，无需锁，同一时刻只有一个线程能访问数据，通过类似队列的去查找等待的数据。</p>
<p>​        eventlet是一个用来处理和网络相关的python库函数，而且可以通过协程来实现并发，在eventlet里，把“协程”叫做 greenthread(绿色线程)。所谓并发，就是开启了多个greenthread，并且对这些greenthread进行管理，以实现非阻塞式的 I/O。比如说用eventlet可以很方便的写一个性能很好的web服务器，或者是一个效率很高的网页爬虫，这都归功于eventlet的“绿色线程”，以及对“绿色线程”的管理机制。更让人不可思议的是，eventlet为了实现“绿色线程”，竟然对python的和网络相关的几个标准库函数进行了改写，并且可以以补丁（patch）的方式导入到程序中，因为python的库函数只支持普通的线程，而不支持协程，eventlet称之为“绿化”。<br>​       它通过greenlet提供的协程功能，让开发者可以不用将以往的多线程等并发程序的开发方式转变成异步状态机模型，就能直接使用select/epoll/kqueue等操作系统提供的支持高并发IO接口，并且能尽可能地发挥它们在并发上的优势。</p>
<p>eventlet的结构如下图所示,eventlet实现的”并发” 更准确的讲, 是 <strong>IO多路复用</strong>。</p>
<p><img src="/2017/03/06/Python的eventlet使用与理解/2.png" alt=""></p>
<h3 id="python-eventlet-API"><a href="#python-eventlet-API" class="headerlink" title="python-eventlet API?"></a>python-eventlet API?</h3><p><strong>Greenthread Spawn</strong> (spawn，孵化的意思，即如何产生greenthread)</p>
<p> 主要有3个函数可以创建绿色线程：</p>
<p> 1)eventlet.spawn(func, <em>args, *</em>kwargs)：</p>
<p>​       创建一个绿色线程去运行func这个函数，后面的参数是传递给这个函数的参数。返回值是一个eventlet.GreenThread对象，这个对象可以用来接受func函数运行的返回值。在绿色线程池还没有满的情况下，这个绿色线程一被创建就立刻被执行。其实，用这种方法去创建线程也是可以理解的，线程被创建出来，肯定是有一定的任务要去执行，这里直接把函数当作参数传递进去，去执行一定的任务，就好像标准库中的线程用run()方法去执行任务一样。</p>
<p>2)eventlet.spawn_n(func, <em>args, *</em>kwargs)：</p>
<p>  这个函数和spawn()类似，不同的就是它没有返回值，因而更加高效，这种特性，使它也有存在的价值。</p>
<p> 3)eventlet.spawn_after(seconds, func, <em>args, *</em>kwargs)：</p>
<p>这个函数和spawn()基本上一样，都有一样的返回值，不同的是它可以限定在什么时候执行这个绿色线程，即在seconds秒之后，启动这个绿色线程。</p>
<p><strong>Greenthread Control</strong></p>
<p>1）eventlet.sleep(seconds=0)</p>
<p> 悬挂当前的绿色线程，以允许其它的绿色线程执行</p>
<p>2）class eventlet.GreenPool</p>
<p>​      这是一个类，在这个类中用set集合来容纳所创建的绿色线程，并且可以指定容纳线程的最大数量（默认是1000个），它的内部是用Semaphore和Event这两个类来对池进行控制的，这样就构成了线程池。其中，有几个比较重要的方法：</p>
<p>​      free()</p>
<p>​      imap(function, *iterables)</p>
<p>​      resize(new_size)</p>
<p>​     running()</p>
<p>​     spawn(function, <em>args, *</em>kwargs)</p>
<p>​     spawn_n(function, <em>args, *</em>kwargs)</p>
<p>​     starmap(function, iterable)</p>
<p>​     waitall()</p>
<p>​     waiting()</p>
<p>3）class eventlet.GreenPile</p>
<p>这也是一个类，而且是一个很有用的类，在它内部维护了一个GreenPool对象和一个Queue对象。这个GreenPool对象可以是从外部传递进来的，也可以是在类内部创建的，GreenPool对象主要是用来创建绿色线程的，即在GreenPile内部调用了GreenPool.spawn()方法。而Queue对象则是用来保存spawn()方法的返回值的，即Queue中保存的是GreenThread对象。并且它还实现了next()方法，也就意味着GreenPile对象具有了迭代器的性质。所以如果我们要对绿色线程的返回值进行操作的话，用这个类是再好不过的了。</p>
<p>   next()<br>Wait for the next result, suspending the current greenthread until it is available. Raises StopIteration when there are no more results.</p>
<p>  spawn(func, <em>args, *</em>kw)<br>Runs func in its own green thread, with the result available by iterating over the GreenPile object</p>
<p>4）class eventlet.Queue</p>
<p>​       基类是LightQueue，它实现了大部分的队列的常用方法。它是用collections做为实现队列的基本数据结构的。而且这个LightQueue的实现，不单单实现了存取操作，在本质上它实现了一个生产者和消费者问题，定义了两个set()类型的成员变量putters和getters，前者用来存放在队列满时，被阻塞的绿色线程，后者用来存放当队列空时，被阻塞的绿色线程。类中的putting()和getting()方法就是分别得到被阻塞的绿色线程的数量。Queue继承了LightQueue，并且又增加了它自己的两个方法：task_done()和join()。task_done()是被消费者的绿色线程所调用的，表示在这个项上的所有工作都做完了，join()是阻塞，直到队列中所有的任务都完成。LifoQueue和PriorityQueue是存放数据的两种不同的方式。</p>
<p><img src="/2017/03/06/Python的eventlet使用与理解/1.png" alt=""></p>
<p>5）class eventlet.Timeout</p>
<p>This class is a way to add timeouts to anything. It raises exception in the current greenthread after timeout seconds. When exception is omitted or None, the Timeout instance itself is raised.</p>
<p><strong>Patching Functions</strong></p>
<p>这里就是之前所说的“绿化”，经过eventlet“绿化”过的模块都在eventlet.green中，导入他们主要有两种方法：</p>
<p>1) eventlet.import_patched(modulename, <em>additional_modules, *</em>kw_additional_modules)</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">from</span> eventlet.green <span class="keyword">import</span> socket</div><div class="line"><span class="keyword">from</span> eventlet.green <span class="keyword">import</span> SocketServer</div><div class="line">BaseHTTPServer = eventlet.import_patched(<span class="string">'BaseHTTPServer'</span>,</div><div class="line">                        (<span class="string">'socket'</span>, socket),</div><div class="line">                        (<span class="string">'SocketServer'</span>, SocketServer))</div><div class="line">BaseHTTPServer = eventlet.import_patched(<span class="string">'BaseHTTPServer'</span>,</div><div class="line">                        socket=socket, SocketServer=SocketServer)</div></pre></td></tr></table></figure>
<p>  2）eventlet.monkey_patch(all=True, os=False, select=False, socket=False, thread=False, time=False)</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> eventlet</div><div class="line">eventlet.monkey_patch(socket=<span class="keyword">True</span>, select=<span class="keyword">True</span>)</div></pre></td></tr></table></figure>
<p><strong>Network Convenience Functions（和网络相关的函数）</strong></p>
<p>eventlet.connect(addr, family=<addressfamily.af_inet: 2="">, bind=None)</addressfamily.af_inet:></p>
<p>主要执行了以下几个步骤：新建了一个TCP类型的socket，绑定本地的ip和端口，和远程的地址进行连接</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">connect</span><span class="params">(addr, family=socket.AF_INET, bind=None)</span>:</span>  </div><div class="line">    sock = socket.socket(family, socket.SOCK_STREAM)  </div><div class="line">    <span class="keyword">if</span> bind <span class="keyword">is</span> <span class="keyword">not</span> <span class="keyword">None</span>:  </div><div class="line">        sock.bind(bind)  </div><div class="line">    sock.connect(addr)  </div><div class="line">    <span class="keyword">return</span> sock</div></pre></td></tr></table></figure>
<p>eventlet.listen(addr, family=<addressfamily.af_inet: 2="">, backlog=50)</addressfamily.af_inet:></p>
<p>和connect()类似，只是把connect()换成了listen()，backlog指定了最大的连接数量</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">listen</span><span class="params">(addr, family=socket.AF_INET, backlog=<span class="number">50</span>)</span>:</span>  </div><div class="line">    sock = socket.socket(family, socket.SOCK_STREAM)  </div><div class="line">    <span class="keyword">if</span> sys.platform[:<span class="number">3</span>]==<span class="string">"win"</span>:  </div><div class="line">        sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, <span class="number">1</span>)  <span class="comment">#这段不知道具体是做什么的  </span></div><div class="line">    sock.bind(addr)  </div><div class="line">    sock.listen(backlog)  </div><div class="line">    <span class="keyword">return</span> sock</div></pre></td></tr></table></figure>
<p>eventlet.wrap_ssl(sock, <em>a, *</em>kw)</p>
<p>给socket加上ssl(安全套接层)，对数据进行加密</p>
<p>eventlet.serve(sock, handle, concurrency=1000)</p>
<p>这个函数直接创建了一个socket服务器，在它内部创建了一个GreenPool对象，默认的最大绿色线程数是1000，然后是一个循环来接受连接</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">serve</span><span class="params">(sock, handle, concurrency=<span class="number">1000</span>)</span>:</span>  </div><div class="line">    pool = greenpool.GreenPool(concurrency)  </div><div class="line">    server_gt = greenthread.getcurrent()  </div><div class="line">   </div><div class="line">    <span class="keyword">while</span> <span class="keyword">True</span>:  </div><div class="line">        <span class="keyword">try</span>:  </div><div class="line">            conn, addr = sock.accept()  </div><div class="line">            gt = pool.spawn(handle, conn, addr)  </div><div class="line">            gt.link(_stop_checker, server_gt, conn)  </div><div class="line">            conn, addr, gt = <span class="keyword">None</span>, <span class="keyword">None</span>, <span class="keyword">None</span>  </div><div class="line">        <span class="keyword">except</span> StopServe:  </div><div class="line">            <span class="keyword">return</span></div></pre></td></tr></table></figure>
<h3 id="eventlet-中的wsgi？"><a href="#eventlet-中的wsgi？" class="headerlink" title="eventlet 中的wsgi？"></a>eventlet 中的wsgi？</h3><p>流程描述：</p>
<p>服务器开一个socket等待客户端连接；请求来了，服务器会读出传来的数据，然后根据HTTP协议做一些初步的封装，接着就可以调用事先注册的应用程序了，并将请求的数据塞进去；等响应处理完毕了再把数据通过socket发出去。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">server参数介绍：</div><div class="line"></div><div class="line">def server(sock,  # Server socket, must be already bound to a port and listening(IP和端口并开启监听).</div><div class="line">           site,  # WSGI application function(事件处理函数，发送start_response响应头然后返回响应内容)</div><div class="line">           log=None,  # File-like object that logs should be written to.If not specified, sys.stderr is used.(日志处理，默认为sys.stderr用来重定向标准错误信息的)</div><div class="line">           environ=None,  # Additional parameters that go into the environ dictionary of every request(每次请求的参数，写入一个字典中)</div><div class="line">           max_size=None,  #Maximum number of client connections opened at any time by this server.(默认为1024)</div><div class="line">           max_http_version=DEFAULT_MAX_HTTP_VERSION,  # Set to "HTTP/1.0" to make the server pretend it only supports HTTP 1.0.</div><div class="line">　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　# This can help with applications or clients that don't behave properly using HTTP 1.1.(HTTP协议版本,默认为HTTP/1.1)</div><div class="line">           protocol=HttpProtocol,  # Protocol class.（协议类，默认为HttpProtocol）</div><div class="line">           server_event=None,  # Used to collect the Server object(搜集服务器对象信息)</div><div class="line">           minimum_chunk_size=None,  # Minimum size in bytes for http chunks.  This can be used to improve performance of applications which yield many small strings, though</div><div class="line">　　　　　　　　　　　　　　　　　　　　　 # using it technically violates the WSGI spec. This can be overridden on a per request basis by setting environ['eventlet.minimum_write_chunk_size'].</div><div class="line">　　　　　　　　　　　　　　　　　　　　　 # 设置最小的Chunk大小，可以通过设置environ['eventlet.minimum_write_chunk_size']来覆盖.Chunk表示服务器发送给客户端的分块传输编码（Chunked transfer encoding）</div><div class="line">           log_x_forwarded_for=True,  # If True (the default), logs the contents of the x-forwarded-for header in addition to the actual client ip address in the 'client_ip' field of the log line.</div><div class="line">　　　　　　　　　　　　　　　　　　　　　　# 默认为True,记录客户端IP日志,X-Forwarded-For(XFF)是用来识别通过HTTP代理或负载均衡方式连接到Web服务器的客户端最原始的IP地址的HTTP请求头字段。</div><div class="line">           custom_pool=None,  # A custom GreenPool instance which is used to spawn client green threads.If this is supplied, max_size is ignored.(协程池，如果启用则可以忽略前面的max_size参数)</div><div class="line">           keepalive=True,  # If set to False, disables keepalives on the server; all connections will be closed after serving one request.（控制客户端连接数是否保持alive）</div><div class="line">           log_output=True,  # A Boolean indicating if the server will log data or not.(确定服务端是否输出日志)</div><div class="line">           log_format=DEFAULT_LOG_FORMAT,  # A python format string that is used as the template to generate log lines.(日志输出格式)</div><div class="line">           url_length_limit=MAX_REQUEST_LINE,  # A maximum allowed length of the request url. If exceeded, 414 error is returned.（最大的url长度限制，默认为8192）</div><div class="line">           debug=True, # True if the server should send exception tracebacks to the clients on 500 errors.If False, the server will respond with empty bodies.(是否发送调式信息给客户端)</div><div class="line">           socket_timeout=None,  # Timeout for client connections' socket operations. Default None means wait forever.(Socket超时时间设置，单位是秒)</div><div class="line">           capitalize_response_headers=True)  # Normalize response headers' names to Foo-Bar(是否标准化相应头)</div></pre></td></tr></table></figure>
<p>Client端：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="comment">#客户端代码：</span></div><div class="line"><span class="keyword">import</span> eventlet</div><div class="line">c=eventlet.connect((<span class="string">'127.0.0.1'</span>, <span class="number">6000</span>))</div><div class="line"><span class="keyword">while</span> <span class="keyword">True</span>:</div><div class="line">    data=raw_input(<span class="string">'Enter data:'</span>)</div><div class="line">    c.sendall(data)</div><div class="line">    rc=c.recv(<span class="number">1024</span>)</div><div class="line">    <span class="keyword">print</span> rc</div></pre></td></tr></table></figure>
<p>Server端：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="comment">#服务端代码：</span></div><div class="line"><span class="keyword">import</span> eventlet</div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">handle</span><span class="params">(client)</span>:</span></div><div class="line">    <span class="keyword">while</span> <span class="keyword">True</span>:</div><div class="line">        c = client.recv(<span class="number">1024</span>)</div><div class="line">        <span class="keyword">print</span> c</div><div class="line">        client.sendall(c)</div><div class="line">server = eventlet.listen((<span class="string">'127.0.0.1'</span>, <span class="number">6000</span>))</div><div class="line">pool = eventlet.GreenPool(<span class="number">10000</span>)</div><div class="line"><span class="keyword">while</span> <span class="keyword">True</span>:</div><div class="line">    new_sock, address = server.accept()</div><div class="line">    pool.spawn_n(handle, new_sock)</div></pre></td></tr></table></figure>
<h3 id="python-eventlet-的Demo"><a href="#python-eventlet-的Demo" class="headerlink" title="python-eventlet 的Demo?"></a>python-eventlet 的Demo?</h3><p>官方上引以为傲的“网页爬虫”，用到了绿色线程池和imap()函数</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">urls = [</div><div class="line">    <span class="string">"http://www.google.com/intl/en_ALL/images/logo.gif"</span>,</div><div class="line">    <span class="string">"http://python.org/images/python-logo.gif"</span>,</div><div class="line">    <span class="string">"http://us.i1.yimg.com/us.yimg.com/i/ww/beta/y3.gif"</span>,</div><div class="line">]</div><div class="line"></div><div class="line"><span class="keyword">import</span> eventlet</div><div class="line"><span class="keyword">from</span> eventlet.green <span class="keyword">import</span> urllib2</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">fetch</span><span class="params">(url)</span>:</span></div><div class="line">    <span class="keyword">return</span> urllib2.urlopen(url).read()</div><div class="line"></div><div class="line">pool = eventlet.GreenPool()</div><div class="line"><span class="keyword">for</span> body <span class="keyword">in</span> pool.imap(fetch, urls):</div><div class="line">    print(<span class="string">"got body"</span>, len(body))</div></pre></td></tr></table></figure>
<h3 id="源码级别的分析？"><a href="#源码级别的分析？" class="headerlink" title="源码级别的分析？"></a>源码级别的分析？</h3><p>eventlet主要依赖另外2个python package:</p>
<p>greenlet<br>python-epoll (或其他类似的异步IO库, 如poll/select等)</p>
<p>主要做了3个工作:</p>
<p>封装greenlet<br>封装epoll<br>改写python标准库中相关的module, 以便支持epoll</p>
<p><strong>什么是epoll？</strong></p>
<p>epoll是linux实现的一个基于事件的异步IO库, 在之前类似的异步IO库poll上改进而来。</p>
<p>下面两个例子会演示如何用epoll将阻塞的IO操作用epoll改写为异步非阻塞：</p>
<p>blocking IO</p>
<p>import socket</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">EOL1 = <span class="string">b'\n\n'</span></div><div class="line">EOL2 = <span class="string">b'\n\r\n'</span></div><div class="line">response  = <span class="string">b'HTTP/1.0 200 OK\r\nDate: Mon, 1 Jan 1996 01:01:01 GMT\r\n'</span></div><div class="line">response += <span class="string">b'Content-Type: text/plain\r\nContent-Length: 13\r\n\r\n'</span></div><div class="line">response += <span class="string">b'Hello, world!'</span></div><div class="line"></div><div class="line">serversocket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)</div><div class="line">serversocket.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, <span class="number">1</span>)</div><div class="line">serversocket.bind((<span class="string">'0.0.0.0'</span>, <span class="number">8080</span>))</div><div class="line">serversocket.listen(<span class="number">1</span>)</div><div class="line"></div><div class="line"><span class="keyword">try</span>:</div><div class="line">    <span class="keyword">while</span> <span class="keyword">True</span>:</div><div class="line">        connectiontoclient, address = serversocket.accept()</div><div class="line">        request = <span class="string">b''</span></div><div class="line">        <span class="keyword">while</span> EOL1 <span class="keyword">not</span> <span class="keyword">in</span> request <span class="keyword">and</span> EOL2 <span class="keyword">not</span> <span class="keyword">in</span> request:</div><div class="line">            request += connectiontoclient.recv(<span class="number">1024</span>)</div><div class="line">        print(<span class="string">'-'</span>*<span class="number">40</span> + <span class="string">'\n'</span> + request.decode()[:<span class="number">-2</span>])</div><div class="line">        connectiontoclient.send(response)</div><div class="line">        connectiontoclient.close()</div><div class="line"><span class="keyword">finally</span>:</div><div class="line">    serversocket.close()</div></pre></td></tr></table></figure>
<p>​       需要注意的是程序会在connectiontoclient, address = serversocket.accept()这一行block住, 直到获取到新的连接, 程序才会继续往下运行.同时, 这个程序同一个时间内只能处理一个连接, 如果有很多用户同时访问8080端口, 必须要按先后 顺序依次处理这些连接, 前面一个连接成功返回后, 才会处理后面的连接.</p>
<p>non-blocking IO by using epoll</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> socket, select</div><div class="line"></div><div class="line">EOL1 = <span class="string">b'\n\n'</span></div><div class="line">EOL2 = <span class="string">b'\n\r\n'</span></div><div class="line">response  = <span class="string">b'HTTP/1.0 200 OK\r\nDate: Mon, 1 Jan 1996 01:01:01 GMT\r\n'</span></div><div class="line">response += <span class="string">b'Content-Type: text/plain\r\nContent-Length: 13\r\n\r\n'</span></div><div class="line">response += <span class="string">b'Hello, world!'</span></div><div class="line"></div><div class="line">serversocket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)</div><div class="line">serversocket.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, <span class="number">1</span>)</div><div class="line">serversocket.bind((<span class="string">'0.0.0.0'</span>, <span class="number">8080</span>))</div><div class="line">serversocket.listen(<span class="number">1</span>)</div><div class="line">serversocket.setblocking(<span class="number">0</span>)</div><div class="line"></div><div class="line">epoll = select.epoll()</div><div class="line">epoll.register(serversocket.fileno(), select.EPOLLIN)</div><div class="line"></div><div class="line"><span class="keyword">try</span>:</div><div class="line">    connections = &#123;&#125;; requests = &#123;&#125;; responses = &#123;&#125;</div><div class="line">    <span class="keyword">while</span> <span class="keyword">True</span>:</div><div class="line">        events = epoll.poll(<span class="number">1</span>)</div><div class="line">        <span class="keyword">for</span> fileno, event <span class="keyword">in</span> events:</div><div class="line">            <span class="keyword">if</span> fileno == serversocket.fileno():</div><div class="line">                connection, address = serversocket.accept()</div><div class="line">                connection.setblocking(<span class="number">0</span>)</div><div class="line">                epoll.register(connection.fileno(), select.EPOLLIN)</div><div class="line">                connections[connection.fileno()] = connection</div><div class="line">                requests[connection.fileno()] = <span class="string">b''</span></div><div class="line">                responses[connection.fileno()] = response</div><div class="line">            <span class="keyword">elif</span> event &amp; select.EPOLLIN:</div><div class="line">                requests[fileno] += connections[fileno].recv(<span class="number">1024</span>)</div><div class="line">                <span class="keyword">if</span> EOL1 <span class="keyword">in</span> requests[fileno] <span class="keyword">or</span> EOL2 <span class="keyword">in</span> requests[fileno]:</div><div class="line">                    epoll.modify(fileno, select.EPOLLOUT)</div><div class="line">                    print(<span class="string">'-'</span>*<span class="number">40</span> + <span class="string">'\n'</span> + requests[fileno].decode()[:<span class="number">-2</span>])</div><div class="line">            <span class="keyword">elif</span> event &amp; select.EPOLLOUT:</div><div class="line">                byteswritten = connections[fileno].send(responses[fileno])</div><div class="line">                responses[fileno] = responses[fileno][byteswritten:]</div><div class="line">                <span class="keyword">if</span> len(responses[fileno]) == <span class="number">0</span>:</div><div class="line">                    epoll.modify(fileno, <span class="number">0</span>)</div><div class="line">                    connections[fileno].shutdown(socket.SHUT_RDWR)</div><div class="line">            <span class="keyword">elif</span> event &amp; select.EPOLLHUP:</div><div class="line">                epoll.unregister(fileno)</div><div class="line">                connections[fileno].close()</div><div class="line">                <span class="keyword">del</span> connections[fileno]</div><div class="line"><span class="keyword">finally</span>:</div><div class="line">    epoll.unregister(serversocket.fileno())</div><div class="line">    epoll.close()</div><div class="line">    serversocket.close()</div></pre></td></tr></table></figure>
<p>可以看到, 例子中首先使用serversocket.setblocking(0)将socket设为异步的模式,然后 用select.epoll()新建了一个epoll, 接着用epoll.register(serversocket.fileno(),select.EPOLLIN)将该socket上的IO输入事件(select.EPOLLIN<br>)注册到epoll里.这样做了以后, 就可以将 上面例子中会在socket.accept()这步阻塞的MainLoop改写为基于异步IO事件的epoll循环了.events = epoll.poll(1)</p>
<p>​       简单的说, 如果有很多用户同时连接到8080端口, 这个程序会同时accept()所有的socket连接, 然后通过这行代码将发生IO事件socket放到events中, 并在后面循环中处理. 没有发生IO事件的 socket不会在loop中做处理. 这样使用epoll就实现了一个简单的并发web服务器.</p>
<p>注意, 这里提到的并发, 和我们通常所理解线程/进程的并发并不太一样, 更准确的说, 是 IO多路复用 .</p>
<p><strong>什么是greenlet？</strong></p>
<p>greentlet是python中实现我们所谓的”Coroutine(协程)”的一个基础库.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">from</span> greenlet <span class="keyword">import</span> greenlet</div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">test1</span><span class="params">()</span>:</span></div><div class="line">    <span class="keyword">print</span> <span class="number">12</span></div><div class="line">    gr2.switch()</div><div class="line">    <span class="keyword">print</span> <span class="number">34</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">test2</span><span class="params">()</span>:</span></div><div class="line">    <span class="keyword">print</span> <span class="number">56</span></div><div class="line">    gr1.switch()</div><div class="line">    <span class="keyword">print</span> <span class="number">78</span></div><div class="line"> gr1 = greenlet(test1)</div><div class="line"> gr2 = greenlet(test2)</div><div class="line"> gr1.switch()</div><div class="line"><span class="comment">#输出</span></div><div class="line"><span class="number">12</span></div><div class="line"><span class="number">56</span></div><div class="line"><span class="number">34</span></div></pre></td></tr></table></figure>
<p>​        程序先分别为两个函数定义了2个greenlet: gr1和gr2.gr1.switch()显式切换到gr1上执行, gr1中输出”12”后gr2.switch()显式切换到gr2上执行输出56, 又gr1.switch()显式切换到gr1上, 输出34. test1()执行结束,gr1 die. 于是 test2()里的78不会输出.可以发现greenlet仅仅是实现了一个最简单的”coroutine”, 而eventlet中的greenthread是在 greenlet的基础上封装了一些更high-level的功能, 比如greenlet的调度等.</p>
<p><strong>什么是eventlet.green？</strong></p>
<p>从epoll的运行机制可以看出, 要使用异步IO, 必须要将相关IO操作改写成non-blocking的方式. 但是我们用<br>eventlet.spawn()的函数,并没有针对epoll做任何改写, 那eventlet是怎么实现 异步IO的呢?这也是eventlet这个package最凶残的地方, 它自己重写了python标准库中IO相关的操作, 将它们 改写成支持epoll的模式, 放在eventlet.green中.比如说, socket.accept()被改成了这样</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">accept</span><span class="params">(self)</span>:</span></div><div class="line">    <span class="keyword">if</span> self.act_non_blocking:</div><div class="line">        <span class="keyword">return</span> self.fd.accept()</div><div class="line">    fd = self.fd</div><div class="line">    <span class="keyword">while</span> <span class="keyword">True</span>:</div><div class="line">        res = socket_accept(fd)</div><div class="line">        <span class="keyword">if</span> res <span class="keyword">is</span> <span class="keyword">not</span> <span class="keyword">None</span>:</div><div class="line">            client, addr = res</div><div class="line">            set_nonblocking(client)</div><div class="line">            <span class="keyword">return</span> type(self)(client), addr</div><div class="line">        trampoline(fd, read=<span class="keyword">True</span>, timeout=self.gettimeout(),</div><div class="line">                       timeout_exc=socket.timeout(<span class="string">"timed out"</span>))</div></pre></td></tr></table></figure>
<p>​        然后在eventlet.spawn()的时候, 通过 一些高阶魔法和”huge hack”, 将这些改写过得模块”patch”到spawn出的greenthread上, 从而 实现epoll的IO多路复用, 相当凶残.其中的hub和greenthread分别对应eventlet.hubs.hub和eventlet.greenthread, 本质都是 一个greenlet的实例.hub中封装前面提到的epoll, epoll的事件循环是由hub.run()这个方法里实现.每当用户调用 eventlet.spawn(), 就会在当前python线程的pool里产生一个新的greenthread. 由于greenthread 里的IO相关的python标准库被改写成non-blocking的模式(参考上面的socket.accept()).每当greenthread里做IO相关的操作时, 最终都会返回到hub中的epoll循环, 然后根据epoll中的 IO事件, 调用响应的函数. 具体如下面所示.greenthread.sleep(), 实际上也是将CPU控制权交给hub,然后由hub调度下一个需要运行的 greenthread.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">wait</span><span class="params">(self, seconds=None)</span>:</span></div><div class="line">       readers = self.listeners[READ]</div><div class="line">       writers = self.listeners[WRITE]</div><div class="line"></div><div class="line">       <span class="keyword">if</span> <span class="keyword">not</span> readers <span class="keyword">and</span> <span class="keyword">not</span> writers:</div><div class="line">           <span class="keyword">if</span> seconds:</div><div class="line">               sleep(seconds)</div><div class="line">           <span class="keyword">return</span></div><div class="line">       <span class="keyword">try</span>:</div><div class="line">           presult = self.poll.poll(int(seconds * self.WAIT_MULTIPLIER))</div><div class="line">       <span class="keyword">except</span> select.error, e:</div><div class="line">           <span class="keyword">if</span> get_errno(e) == errno.EINTR:</div><div class="line">               <span class="keyword">return</span></div><div class="line">           <span class="keyword">raise</span></div><div class="line">       SYSTEM_EXCEPTIONS = self.SYSTEM_EXCEPTIONS</div><div class="line"></div><div class="line">       <span class="keyword">for</span> fileno, event <span class="keyword">in</span> presult:</div><div class="line">           <span class="keyword">try</span>:</div><div class="line">               <span class="keyword">if</span> event &amp; READ_MASK:</div><div class="line">                   readers.get(fileno, noop).cb(fileno)</div><div class="line">               <span class="keyword">if</span> event &amp; WRITE_MASK:</div><div class="line">                   writers.get(fileno, noop).cb(fileno)</div><div class="line">               <span class="keyword">if</span> event &amp; select.POLLNVAL:</div><div class="line">                   self.remove_descriptor(fileno)</div><div class="line">                   <span class="keyword">continue</span></div><div class="line">               <span class="keyword">if</span> event &amp; EXC_MASK:</div><div class="line">                   readers.get(fileno, noop).cb(fileno)</div><div class="line">                   writers.get(fileno, noop).cb(fileno)</div><div class="line">           <span class="keyword">except</span> SYSTEM_EXCEPTIONS:</div><div class="line">               <span class="keyword">raise</span></div><div class="line">           <span class="keyword">except</span>:</div><div class="line">               self.squelch_exception(fileno, sys.exc_info())</div><div class="line">               clear_sys_exc_info()</div></pre></td></tr></table></figure>
<h3 id="参考"><a href="#参考" class="headerlink" title="参考:"></a>参考:</h3><p><a href="http://blog.csdn.net/xiangmin2587/article/details/8182775" target="_blank" rel="external">http://blog.csdn.net/xiangmin2587/article/details/8182775</a></p>
<p><a href="http://blog.csdn.net/qq910894904/article/details/41699541" target="_blank" rel="external">http://blog.csdn.net/qq910894904/article/details/41699541</a></p>
<p><a href="http://www.cnblogs.com/wonderKK/p/4062591.html" target="_blank" rel="external">http://www.cnblogs.com/wonderKK/p/4062591.html</a></p>
<p><a href="http://eventlet.net/doc/" target="_blank" rel="external">http://eventlet.net/doc/</a></p>
<p><a href="http://eventlet.net/doc/modules/wsgi.html" target="_blank" rel="external">http://eventlet.net/doc/modules/wsgi.html</a></p>
<p><a href="http://www.xuebuyuan.com/1379840.html" target="_blank" rel="external">http://www.xuebuyuan.com/1379840.html</a></p>

      
    </div>

    <div>
      
        
<div id="wechat_subscriber" style="display: block; padding: 10px 0; margin: 20px auto; width: 100%; text-align: center">
    <img id="wechat_subscriber_qcode" src="/uploads/1.jpg" alt="Luckylau wechat" style="width: 200px; max-width: 100%;"/>
    <div>如果对您有价值,看官可以打赏的！</div>
</div>


      
    </div>

    <div>
      
        

      
    </div>


    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/python/" rel="tag"># python</a>
          
        </div>
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2017/03/03/java框架之SpringBoot/" rel="next" title="java框架之SpringBoot">
                <i class="fa fa-chevron-left"></i> java框架之SpringBoot
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2017/03/06/Python-yield-使用浅析/" rel="prev" title="Python yield 使用浅析">
                Python yield 使用浅析 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </article>



    <div class="post-spread">
      
    </div>
  </div>

          
          </div>
          


          
  <div class="comments" id="comments">
    
  </div>


        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap" >
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/logo.jpg"
               alt="Luckylau" />
          <p class="site-author-name" itemprop="name">Luckylau</p>
          <p class="site-description motion-element" itemprop="description">人生识字忧患始</p>
        </div>
        <nav class="site-state motion-element">
        
          
            <div class="site-state-item site-state-posts">
              <a href="/archives">
                <span class="site-state-item-count">50</span>
                <span class="site-state-item-name">日志</span>
              </a>
            </div>
          

          
            <div class="site-state-item site-state-categories">
              <a href="/categories">
                <span class="site-state-item-count">8</span>
                <span class="site-state-item-name">分类</span>
              </a>
            </div>
          

          
            <div class="site-state-item site-state-tags">
              <a href="/tags">
                <span class="site-state-item-count">13</span>
                <span class="site-state-item-name">标签</span>
              </a>
            </div>
          

        </nav>

        

        <div class="links-of-author motion-element">
          
            
              <span class="links-of-author-item">
                <a href="https://github.com/Luckylau" target="_blank" title="GitHub">
                  
                    <i class="fa fa-fw fa-github"></i>
                  
                  GitHub
                </a>
              </span>
            
              <span class="links-of-author-item">
                <a href="https://weibo.com/2606534415/profile?topnav=1&wvr=6&is_all=1" target="_blank" title="Weibo">
                  
                    <i class="fa fa-fw fa-weibo"></i>
                  
                  Weibo
                </a>
              </span>
            
          
        </div>

        
        

        
        

        


      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-3"><a class="nav-link" href="#什么是协程？"><span class="nav-number">1.</span> <span class="nav-text">什么是协程？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#python-eventlet又是什么"><span class="nav-number">2.</span> <span class="nav-text">python-eventlet又是什么?</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#python-eventlet-API"><span class="nav-number">3.</span> <span class="nav-text">python-eventlet API?</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#eventlet-中的wsgi？"><span class="nav-number">4.</span> <span class="nav-text">eventlet 中的wsgi？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#python-eventlet-的Demo"><span class="nav-number">5.</span> <span class="nav-text">python-eventlet 的Demo?</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#源码级别的分析？"><span class="nav-number">6.</span> <span class="nav-text">源码级别的分析？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#参考"><span class="nav-number">7.</span> <span class="nav-text">参考:</span></a></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2017</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Luckylau</span>
</div>


<div class="powered-by">
  由 <a class="theme-link" href="https://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Pisces
  </a>
</div>


        

<div class="busuanzi-count">

  <script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>

  
    <span class="site-uv"><i class="fa fa-user"></i><span class="busuanzi-value" id="busuanzi_value_site_uv"></span></span>
  

  
    <span class="site-pv"><i class="fa fa-eye"></i><span class="busuanzi-value" id="busuanzi_value_site_pv"></span></span>
  
  
</div>



        
      </div>
    </footer>

    <div class="back-to-top">
      <i class="fa fa-arrow-up"></i>
    </div>
  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  




  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.0"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.0"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.0"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.0"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.0"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.0"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.0"></script>



  



  




	





  





  

  
      <!-- UY BEGIN -->
      <script type="text/javascript" src="http://v2.uyan.cc/code/uyan.js?uid="></script>
      <!-- UY END -->
  




  
  
  <script type="text/javascript">
    // Popup Window;
    var isfetched = false;
    // Search DB path;
    var search_path = "search.xml";
    if (search_path.length == 0) {
      search_path = "search.xml";
    }
    var path = "/" + search_path;
    // monitor main search box;

    function proceedsearch() {
      $("body").append('<div class="popoverlay">').css('overflow', 'hidden');
      $('.popup').toggle();
    }
    // search function;
    var searchFunc = function(path, search_id, content_id) {
      'use strict';
      $.ajax({
        url: path,
        dataType: "xml",
        async: true,
        success: function( xmlResponse ) {
          // get the contents from search data
          isfetched = true;
          $('.popup').detach().appendTo('.header-inner');
          var datas = $( "entry", xmlResponse ).map(function() {
            return {
              title: $( "title", this ).text(),
              content: $("content",this).text(),
              url: $( "url" , this).text()
            };
          }).get();
          var $input = document.getElementById(search_id);
          var $resultContent = document.getElementById(content_id);
          $input.addEventListener('input', function(){
            var matchcounts = 0;
            var str='<ul class=\"search-result-list\">';
            var keywords = this.value.trim().toLowerCase().split(/[\s\-]+/);
            $resultContent.innerHTML = "";
            if (this.value.trim().length > 1) {
              // perform local searching
              datas.forEach(function(data) {
                var isMatch = false;
                var content_index = [];
                var data_title = data.title.trim().toLowerCase();
                var data_content = data.content.trim().replace(/<[^>]+>/g,"").toLowerCase();
                var data_url = decodeURIComponent(data.url);
                var index_title = -1;
                var index_content = -1;
                var first_occur = -1;
                // only match artiles with not empty titles and contents
                if(data_title != '') {
                  keywords.forEach(function(keyword, i) {
                    index_title = data_title.indexOf(keyword);
                    index_content = data_content.indexOf(keyword);
                    if( index_title >= 0 || index_content >= 0 ){
                      isMatch = true;
                      if (i == 0) {
                        first_occur = index_content;
                      }
                    }

                  });
                }
                // show search results
                if (isMatch) {
                  matchcounts += 1;
                  str += "<li><a href='"+ data_url +"' class='search-result-title'>"+ data_title +"</a>";
                  var content = data.content.trim().replace(/<[^>]+>/g,"");
                  if (first_occur >= 0) {
                    // cut out 100 characters
                    var start = first_occur - 20;
                    var end = first_occur + 80;
                    if(start < 0){
                      start = 0;
                    }
                    if(start == 0){
                      end = 50;
                    }
                    if(end > content.length){
                      end = content.length;
                    }
                    var match_content = content.substring(start, end);
                    // highlight all keywords
                    keywords.forEach(function(keyword){
                      var regS = new RegExp(keyword, "gi");
                      match_content = match_content.replace(regS, "<b class=\"search-keyword\">"+keyword+"</b>");
                    });

                    str += "<p class=\"search-result\">" + match_content +"...</p>"
                  }
                  str += "</li>";
                }
              })};
            str += "</ul>";
            if (matchcounts == 0) { str = '<div id="no-result"><i class="fa fa-frown-o fa-5x" /></div>' }
            if (keywords == "") { str = '<div id="no-result"><i class="fa fa-search fa-5x" /></div>' }
            $resultContent.innerHTML = str;
          });
          proceedsearch();
        }
      });}

    // handle and trigger popup window;
    $('.popup-trigger').click(function(e) {
      e.stopPropagation();
      if (isfetched == false) {
        searchFunc(path, 'local-search-input', 'local-search-result');
      } else {
        proceedsearch();
      };
    });

    $('.popup-btn-close').click(function(e){
      $('.popup').hide();
      $(".popoverlay").remove();
      $('body').css('overflow', '');
    });
    $('.popup').click(function(e){
      e.stopPropagation();
    });
  </script>


  

  

  

  


</body>
</html>
