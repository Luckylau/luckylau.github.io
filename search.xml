<?xml version="1.0" encoding="utf-8"?>
<search>
  
    
    <entry>
      <title><![CDATA[HttpClient工具类]]></title>
      <url>%2F2017%2F02%2F15%2FHttpClient%E5%B7%A5%E5%85%B7%E7%B1%BB%E7%9A%84%E5%B0%81%E8%A3%85%2F</url>
      <content type="text"><![CDATA[一.HttpClient 介绍：​ HttpClient相比传统JDK自带的URLConnection，增加了易用性和灵活性，它不仅是客户端发送Http请求变得容易，而且也方便了开发人员测试接口（基于Http协议的），即提高了开发的效率，也方便提高代码的健壮性。它支持在HTTP/1.1规范中定义的所有的HTTP方法：GET, HEAD, POST, PUT, DELETE, TRACE 和 OPTIONS。每有一个方法都有一个对应的类：HttpGet，HttpHead，HttpPost，HttpPut，HttpDelete，HttpTrace和HttpOptions。所有的这些类均实现了HttpUriRequest接口，故可以作为execute的执行参数使用。 HTTP请求的URI包含一个协议计划protocol scheme，主机名host name,，可选的端口optional port，资源的路径resource path，可选的查询optional query和可选的片段optional fragment。 二. 特性：​ 基于标准、纯净的Java语言。实现了Http1.0和Http1.1 ​ 以可扩展的面向对象的结构实现了Http全部的方法（GET, POST, PUT, DELETE, HEAD, OPTIONS, and TRACE）。 ​ 支持HTTPS协议。 ​ 通过Http代理建立透明的连接。 ​ 利用CONNECT方法通过Http代理建立隧道的https连接。 ​ Basic, Digest, NTLMv1, NTLMv2, NTLM2 Session, SNPNEGO/Kerberos认证方案。 ​ 插件式的自定义认证方案。 ​ 便携可靠的套接字工厂使它更容易的使用第三方解决方案。 ​ 连接管理器支持多线程应用。支持设置最大连接数，同时支持设置每个主机的最大连接数，发现并关闭过期的连接。 ​ 自动处理Set-Cookie中的Cookie。 ​ 插件式的自定义Cookie策略。 ​ Request的输出流可以避免流中内容直接缓冲到socket服务器。 ​ Response的输入流可以有效的从socket服务器直接读取相应内容。 ​ 在http1.0和http1.1中利用KeepAlive保持持久连接。 ​ 直接获取服务器发送的response code和 headers。 ​ 设置连接超时的能力。 ​ 实验性的支持http1.1 response caching。 ​ 源代码基于Apache License 可免费获取。 三. 使用方法​ 创建HttpClient对象。 ​ 创建请求方法的实例，并指定请求URL。如果需要发送GET请求，创建HttpGet对象；如果需要发送POST请求，创建HttpPost对象。 ​ 如果需要发送请求参数，可调用HttpGet、HttpPost共同的setParams(HetpParams params)方法来添加请求参数；对于HttpPost对象而言，也可调用setEntity(HttpEntity entity)方法来设置请求参数。 ​ 调用HttpClient对象的execute(HttpUriRequest request)发送请求，该方法返回一个HttpResponse。 ​ 调用HttpResponse的getAllHeaders()、getHeaders(String name)等方法可获取服务器的响应头；调用HttpResponse的getEntity()方法可获取HttpEntity对象，该对象包装了服务器的响应内容。程序可通过该对象获取服务器的响应内容。 ​ 释放连接。无论执行方法是否成功，都必须释放连接 四.封装工具类​ 1.HttpHeader封装 ​ 2.SSL封装 ​ 链接：https://github.com/Luckylau/UsefulTools 五.参考资料http://blog.csdn.net/xiaoxian8023/article/category/5968067 http://blog.csdn.net/wangpeng047/article/details/19624529]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[BeanUtils.copyProperties 与 PropertyUtils.copyProperties]]></title>
      <url>%2F2017%2F02%2F06%2FBeanUtils-copyProperties-%E4%B8%8E-PropertyUtils-copyProperties%2F</url>
      <content type="text"><![CDATA[首先明确一点是BeanUtils.copyProperties 存在于spring和apache commons-beanutils，PropertyUtils.copyProperties存在于apache commons-PropertyUtils。 org.springframework.beans.BeanUtils; org.apache.commons.beanutils.BeanUtils; org.apache.commons.beanutils.PropertyUtils; 1.org.springframework.beans.BeanUtils使用：首先看一下源码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657public static void copyProperties(Object source, Object target) throws BeansException &#123; copyProperties(source, target, (Class)null, (String[])null); &#125; public static void copyProperties(Object source, Object target, Class&lt;?&gt; editable) throws BeansException &#123; copyProperties(source, target, editable, (String[])null); &#125; public static void copyProperties(Object source, Object target, String... ignoreProperties) throws BeansException &#123; copyProperties(source, target, (Class)null, ignoreProperties); &#125; private static void copyProperties(Object source, Object target, Class&lt;?&gt; editable, String... ignoreProperties) throws BeansException &#123; Assert.notNull(source, "Source must not be null"); Assert.notNull(target, "Target must not be null"); Class actualEditable = target.getClass(); if(editable != null) &#123; if(!editable.isInstance(target)) &#123; throw new IllegalArgumentException("Target class [" + target.getClass().getName() + "] not assignable to Editable class [" + editable.getName() + "]"); &#125; actualEditable = editable; &#125; PropertyDescriptor[] targetPds = getPropertyDescriptors(actualEditable); List ignoreList = ignoreProperties != null?Arrays.asList(ignoreProperties):null; PropertyDescriptor[] var7 = targetPds; int var8 = targetPds.length; for(int var9 = 0; var9 &lt; var8; ++var9) &#123; PropertyDescriptor targetPd = var7[var9]; Method writeMethod = targetPd.getWriteMethod(); if(writeMethod != null &amp;&amp; (ignoreList == null || !ignoreList.contains(targetPd.getName()))) &#123; PropertyDescriptor sourcePd = getPropertyDescriptor(source.getClass(), targetPd.getName()); if(sourcePd != null) &#123; Method readMethod = sourcePd.getReadMethod(); if(readMethod != null &amp;&amp; ClassUtils.isAssignable(writeMethod.getParameterTypes()[0], readMethod.getReturnType())) &#123; try &#123; if(!Modifier.isPublic(readMethod.getDeclaringClass().getModifiers())) &#123; readMethod.setAccessible(true); &#125; Object ex = readMethod.invoke(source, new Object[0]); if(!Modifier.isPublic(writeMethod.getDeclaringClass().getModifiers())) &#123; writeMethod.setAccessible(true); &#125; writeMethod.invoke(target, new Object[]&#123;ex&#125;); &#125; catch (Throwable var15) &#123; throw new FatalBeanException("Could not copy property \'" + targetPd.getName() + "\' from source to target", var15); &#125; &#125; &#125; &#125; &#125; &#125; 成员变量赋值是基于目标对象的成员列表, 并且会跳过ignore的以及在源对象中不存在的属性, 所以这个方法是安全的, 不会因为两个对象之间的结构差异导致错误, 但是必须保证同名的两个成员变量类型相同. 1BeanUtils.copyProperties(source, target); 2.org.apache.commons.beanutils.BeanUtils使用：2.1 对于类型为Boolean/Short/Integer/Float/Double的属性，它会转换为0: 1234567891011121314151617181920212223242526public class User &#123; private Integer intVal; private Double doubleVal; private Short shortVal; private Long longVal; private Float floatVal; private Byte byteVal; private Boolean booleanVal; &#125; User src = new User(); User dest = new User(); BeanUtils.copyProperties(dest, src); System.out.println(src); System.out.println(dest); //输出 User [intVal=null, doubleVal=null, shortVal=null, longVal=null, floatVal=null, byteVal=null, booleanVal=null] User [intVal=0, doubleVal=0.0, shortVal=0, longVal=0, floatVal=0.0, byteVal=0, booleanVal=false] 在stackoverflow上有人解释说是因为这几个类型都有对应的基本类型，在进行类型转换时，有可能遇到类似Integer -&gt; int的转换，此时显然不能对int类型的属性赋值为null，因此统一转换为0。 如何让它不要转为0呢？可以这样： 1234import org.apache.commons.beanutils.converters.IntegerConverter; IntegerConverter converter = new IntegerConverter(null); //默认为null，而不是0 BeanUtilsBean beanUtilsBean = new BeanUtilsBean(); beanUtilsBean.getConvertUtils().register(converter, Integer.class); 2.2 对于java.util.Date/BigDecimal/java.sql.Date/java.sql.Timestamp/java.sql.Time这几个类，如果值为null，则在copy时会抛异常，需要使用对应的Conveter： 12345678910111213141516171819202122232425262728293031public class User2 &#123; private java.util.Date javaUtilDateVal; private java.sql.Date javaSqlDateVal; private java.sql.Timestamp javaSqlTimeStampVal; private BigDecimal bigDecimalVal; private java.sql.Time javaSqlTime; &#125; User2 src = new User2(); User2 dest = new User2(); BeanUtilsBean beanUtilsBean = new BeanUtilsBean(); //如果没有下面几行，则在转换null时会抛异常，例如：org.apache.commons.beanutils.ConversionException: No value specified for 'BigDecimal' //在org.apache.commons.beanutils.converters这个包下面有很多的Converter，可以按需要使用 beanUtilsBean.getConvertUtils().register(new org.apache.commons.beanutils.converters.BigDecimalConverter(null), BigDecimal.class); beanUtilsBean.getConvertUtils().register(new org.apache.commons.beanutils.converters.DateConverter(null), java.util.Date.class); beanUtilsBean.getConvertUtils().register(new org.apache.commons.beanutils.converters.SqlTimestampConverter(null), java.sql.Timestamp.class); beanUtilsBean.getConvertUtils().register(new org.apache.commons.beanutils.converters.SqlDateConverter(null), java.sql.Date.class); beanUtilsBean.getConvertUtils().register(new org.apache.commons.beanutils.converters.SqlTimeConverter(null), java.sql.Time.class); beanUtilsBean.copyProperties(dest, src); System.out.println(src); System.out.println(dest); 2.3使用BeanUtils还会经常碰到这样变态的需求： 假设是从A复制到B：需求1：如果B中某字段有值（不为null），则该字段不复制；也就是B中该字段没值时，才进行复制，适合于对B进行补充值的情况。需求2：如果A中某字段没值（为null），则该字段不复制，也就是不要把null复制到B当中。 对于需求1，可以这样： 12345678910111213141516171819import org.apache.commons.beanutils.BeanUtilsBean; import org.apache.commons.beanutils.PropertyUtils; public class CopyWhenNullBeanUtilsBean extends BeanUtilsBean&#123; @Override public void copyProperty(Object bean, String name, Object value) throws IllegalAccessException, InvocationTargetException &#123; try &#123; Object destValue = PropertyUtils.getSimpleProperty(bean, name); if (destValue == null) &#123; super.copyProperty(bean, name, value); &#125; &#125; catch (NoSuchMethodException e) &#123; throw new RuntimeException(e); &#125; &#125; &#125; 对于需求2，可以这样： 123456789101112import org.apache.commons.beanutils.BeanUtilsBean; public class CopyFromNotNullBeanUtilsBean extends BeanUtilsBean &#123; @Override public void copyProperty(Object bean, String name, Object value) throws IllegalAccessException, InvocationTargetException &#123; if (value == null) &#123; return; &#125; super.copyProperty(bean, name, value); &#125; &#125; 2.4 使用BeanUtils时，遇到日期类型的空值时会抛错的解决办法 新建一个转换器类，该类实现Converter接口，在convert方法中实现日期类型值的转换逻辑，然后注册。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455public class DateConverter implements Converter&#123; public Object convert(Class type, Object value)&#123; if(value == null)&#123; return null; &#125;else if(type == Timestamp.class)&#123; return convertToDate(type, value, "yyyy-MM-dd HH:mm:ss"); &#125;else if(type == Date.class)&#123; return convertToDate(type, value, "yyyy-MM-dd"); &#125;else if(type == String.class)&#123; return convertToString(type, value); &#125; throw new ConversionException("不能转换 " + value.getClass().getName() + " 为 " + type.getName()); &#125; protected Object convertToDate(Class type, Object value, String pattern) &#123; SimpleDateFormat sdf = new SimpleDateFormat(pattern); if(value instanceof String)&#123; try&#123; if(CommonUtils.isEmpty(value.toString()))&#123; return null; &#125; Date date = sdf.parse((String) value); if(type.equals(Timestamp.class))&#123; return new Timestamp(date.getTime()); &#125; return date; &#125;catch(Exception pe)&#123; return null; &#125; &#125;else if(value instanceof Date)&#123; return value; &#125; throw new ConversionException("不能转换 " + value.getClass().getName() + " 为 " + type.getName()); &#125; protected Object convertToString(Class type, Object value) &#123; if(value instanceof Date)&#123; SimpleDateFormat sdf = new SimpleDateFormat("yyyy-MM-dd"); if (value instanceof Timestamp) &#123; sdf = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss"); &#125; try&#123; return sdf.format(value); &#125;catch(Exception e)&#123; throw new ConversionException("日期转换为字符串时出错！"); &#125; &#125;else&#123; return value.toString(); &#125; &#125; &#125; 1ConvertUtils.register(new DateConverter(), java.util.Date.class); 使用： 1BeanUtils.copyProperties(target, source); 3.org.apache.commons.beanutils.PropertyUtils使用：​ 使用PropertyUtils.copyProperties()拷贝一个bean中的属性到另一个bean中,第一个参数是目标bean,第二个参数是源bean，只是拷贝具有相同的 1PropertyUtils.copyProperties(target, source); 4.三者之间的区别：4.1 org.apache.commons.beanutils.BeanUtils 与org.apache.commons.beanutils.PropertyUtils ​ 从大范围讲，两个工具类都是对两个bean之前存在name相同的属性进行处理，无论是源bean或者目标bean多出的属性均不处理。具体到BeanUtils是相同name并且类型之间支持转换的属性可以处理，而PropertyUtils不支持类型转换必须是类型和name一样才处理。 ​ 对null的处理：PropertyUtils支持为null的场景；BeanUtils对部分属性不支持null的情况，具体为：date类型不支持，异常 date为org.apache.commons.beanutils.ConversionException: No value；specified for ‘Date’；Ineger、Boolean、Long等不支持， 转为0；string支持，保持null； ​ 源bean有属性：private Long dateVal;目标bean有属性：private Date dateVal;​ 使用 PropertyUtils，会报错：Caused by: java.lang.IllegalArgumentException: argument type mismatch​ 使用BeanUtils，则相当于new date（dateVal） ​ BeanUtils的高级功能org.apache.commons.beanutils.Converter接口可以自定义类型之间的转化，PropertyUtils没有 4.2 org.apache.commons.beanutils.BeanUtils与org.springframework.beans.BeanUtils org.springframework.beans.BeanUtils中实现的方式很简单，就是对两个对象中相同名字的属性进行简单get/set，仅检查属性的可访问性。 而org.springframework.beans.BeanUtils则施加了很多的检验，包括类型的转换，甚至于还会检验对象所属的类的可访问性。 5.参考：http://www.cnblogs.com/milton/p/5830942.html http://bylijinnan.iteye.com/blog/2224808 http://caoyaojun1988-163-com.iteye.com/blog/1871316 http://chenjumin.iteye.com/blog/701190 http://www.cnblogs.com/gaojing/archive/2011/08/23/2413616.html]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[历史金融危机一览表]]></title>
      <url>%2F2017%2F01%2F27%2F%E5%8E%86%E5%8F%B2%E9%87%91%E8%9E%8D%E5%8D%B1%E6%9C%BA%E4%B8%80%E8%A7%88%E8%A1%A8%2F</url>
      <content type="text"><![CDATA[历史金融危机一览表]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[什么是vxlan网络]]></title>
      <url>%2F2017%2F01%2F23%2F%E4%BB%80%E4%B9%88%E6%98%AFvxlan%E7%BD%91%E7%BB%9C%2F</url>
      <content type="text"><![CDATA[前言：​ 处在年末工作的最后一天，其实也没有心情学习了，要不就总结和整理一下之前看的vxlan网络，大部分的内容还是复制拷贝的，只是按照自己的分明别类梳理梳理。vxlan网络是云计算网络的基础，openstack本身也是一种基础性简单使用，但还是有必要从理论上来学习vxlan网络。 云计算虚拟化对传统网络带来的挑战​ 云计算、虚拟化相关技术的发展，传统的网络无法满足于规模大、灵活性要求高的云数据中心的要求，于是便有了overlay网络的概念。overlay网络中被广泛应用的就是vxlan技术。首先我们了解一下随着云计算的发展，传统网络面临哪些挑战。 1.虚拟机迁移范围受到网络架构限制 ​ 虚拟机迁移，顾名思义，就是将虚拟机从一个物理机迁移到另一个物理机，但是要求在迁移过程中业务不能中断。要做到这一点，需要保证虚拟机迁移前后，其IP地址、MAC地址等参数维持不变。这就决定了，虚拟机迁移必须发生在一个二层域中。对于传统网络就要求网络本身具备多路径多链路的冗余和可靠性。传统的网络生成树(STPSpaning Tree Protocol)技术不仅部署繁琐荣，且协议复杂，网络规模不宜过大，限制了虚拟化的网络扩展性。基于各厂家私有的的IRF/vPC等设备级的(网络N:1)虚拟化技术，虽然可以简化拓扑简化、具备高可靠性的能力，但是对于网络有强制的拓扑形状限制，在网络的规模和灵活性上有所欠缺，只适合小规模网络构建，且一般适用于数据中心内部网络。而为了大规模网络扩展的TRILL/SPB/FabricPath/VPLS等技术，虽然解决了上述技术的不足，但对网络有特殊要求，即网络中的设备均要软硬件升级而支持此类新技术，带来部署成本的上升。 2.虚拟机规模受网络设备表项规格的限制 ​ 在大二层网络环境下，数据流均需要通过明确的网络寻址以保证准确到达目的地，因此网络设备的二层地址表项大小(即MAC地址表)，成为决定了云计算环境下虚拟机的规模的上限，并且因为表项并非百分之百的有效性，使得可用的虚机数量进一步降低，特别是对于低成本的接入设备而言，因其表项一般规格较小，限制了整个云计算数据中心的虚拟机数量，但如果其地址表项设计为与核心或网关设备在同一档次，则会提升网络建设成本。虽然核心或网关设备的MAC与ARP规格会随着虚拟机增长也面临挑战，但对于此层次设备能力而言，大规格是不可避免的业务支撑要求。减小接入设备规格压力的做法可以是分离网关能力，如采用多个网关来分担虚机的终结和承载，但如此也会带来成本的上升。 3.网络隔离/分离能力限制 ​ VLAN作为当前主流的网络隔离技术，在标准定义中只有12比特，也就是说可用的VLAN数量只有4000个左右。对于公有云或其它大型虚拟化云计算服务这种动辄上万甚至更多租户的场景而言，VLAN的隔离能力显然已经力不从心。 VLAXN网络的初相识1.VXLAN网络模型 从上图可以看到，VXLAN网络中出现了以下传统数据中心网络中没有的新元素： VTEP（VXLAN Tunnel Endpoints，VXLAN隧道端点）VXLAN网络的边缘设备，是VXLAN隧道的起点和终点，VXLAN报文的相关处理均在这上面进行。总之，它是VXLAN网络中绝对的主角。VTEP既可以是独立的网络设备（比如华为的CE系列交换机），也可以是虚拟机所在的服务器。那它究竟是如何发挥作用的呢？答案稍候揭晓。 VNI（VXLAN Network Identifier，VXLAN 网络标识符）前文提到，以太网数据帧中VLAN只占了12比特的空间，这使得VLAN的隔离能力在数据中心网络中力不从心。而VNI的出现，就是专门解决这个问题的。VNI是一种类似于VLAN ID的用户标示，一个VNI代表了一个租户，属于不同VNI的虚拟机之间不能直接进行二层通信。VXLAN报文封装时，给VNI分配了足够的空间使其可以支持海量租户的隔离。详细的实现，我们将在后文中介绍。 VXLAN隧道“隧道”是一个逻辑上的概念，它并不新鲜，比如大家熟悉的GRE。说白了就是将原始报文“变身”下，加以“包装”，好让它可以在承载网络（比如IP网络）上传输。从主机的角度看，就好像原始报文的起点和终点之间，有一条直通的链路一样。而这个看起来直通的链路，就是“隧道”。顾名思义，“VXLAN隧道”便是用来传输经过VXLAN封装的报文的，它是建立在两个VTEP之间的一条虚拟通道。 2.VXLAN是如何解决以上挑战 2.1解决虚拟机迁移范围受到网络架构限制问题 ​ overlay网络的本质是在三层网络中实现二层网络的扩展。三层网络可以通过路由的方式在网络中分发，而路由网络本身并无特殊网络结构限制，具备良性大规模扩展能力，并且对设备本身无特殊要求，以高性能路由转发为佳，且路由网络本身具备很强的的故障自愈能力、负载均衡能力。前面提到，为了保证业务不中断，VM的迁移就必须发生在同一个二层域内。有了VTEP的封装机制和VXLAN隧道后，所谓的 “二层域”就可以轻而易举的突破物理上的界限？也就是说，在IP网络中， “明”里传输的是跨越三层网络的UDP报文，“暗”里却已经悄悄将源VM的原始报文送达目的VM。就好像在三层的网络之上，构建出了一个虚拟的二层网络，而且只要IP网络路由可达，这个虚拟的二层网络想做多大就做多大。 2.2解决虚拟机规模受网络设备表项规格的限制问题 ​ 既然无法提升设备表项规格，那就只能限制设备上的MAC表项，将大量VM的MAC地址“隐形”。VTEP会将VM发出的原始报文封装成一个新的UDP报文，并使用物理网络的IP和MAC地址作为外层头，对网络中的其他设备只表现为封装后的参数。也就是说，网络中的其他设备看不到VM发送的原始报文。 ​ 如果服务器作为VTEP，那从服务器发送到接入设备的报文便是经过封装后的报文，这样，接入设备就不需要学习VM的MAC地址了，它只需要根据外层封装的报文头负责基本的三层转发就可以了。因此，虚拟机规模就不会受网络设备表项规格的限制了。 ​ 当然，如果网络设备作为VTEP，它还是需要学习VM的MAC地址。但是，从对报文进行封装的角度来说，网络设备的性能还是要比服务器强很多。 2.3解决网络隔离/分离能力限制 ​ 一个VNI代表了一个租户，属于不同VNI的虚拟机之间不能直接进行二层通信。VTEP在对报文进行VXLAN封装时，给VNI分配了24比特的空间，这就意味着VXLAN网络理论上支持多达16M（即：2^24-1）的租户隔离。相比VLAN，VNI的隔离能力得到了巨大的提升，有效得解决了云计算中海量租户隔离的问题。 3.VXLAN报文格式 参考： http://support.huawei.com/huaweiconnect/enterprise/forum.php?mod=viewthread&amp;tid=334207&amp;extra=page%3D&amp;page=1 http://blog.csdn.net/sinat_31828101/article/details/50504656]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[什么是overlay网络]]></title>
      <url>%2F2017%2F01%2F23%2F%E4%BB%80%E4%B9%88%E6%98%AFoverllay%E7%BD%91%E7%BB%9C%2F</url>
      <content type="text"><![CDATA[​ Overlay在网络技术领域，指的是一种网络架构上叠加的虚拟化技术模式，其大体框架是对基础网络不进行大规模修改的条件下，实现应用在网络上的承载，并能与其它网络业务分离，并且以基于IP的基础网络技术为主。 ​ 随着云计算虚拟化的驱动，基于主机虚拟化的Overlay技术出现，在服务器的Hypervisor内vSwitch上支持了基于IP的二层Overlay技术，通过更靠近应用的边缘来提供网络虚拟化服务，其目的是使虚拟机的部署与业务活动脱离物理网络及其限制，使得云计算的网络形态不断完善。主机的vSwitch支持基于IP的Overlay之后，虚机的二层访问直接构建在Overlay之上，物理网不再感知虚机的诸多特性。 存在三种不同的构建模式: Network Overlay 方案: ​ 所有终端均采用物理交换机作为VTEP节点,所有的物理接入交换机支持VXLAN，物理服务器支持SR-IOV功能，使虚拟机通过SR-IOV技术直接与物理交换机相连，虚拟机的流量在接入交换机上进行VXLAN报文的封装和卸载，对于非虚拟化服务器，直接连接支持VXLAN的接入交换机，服务器流量在接入交换机上进行VXLAN报文封装和卸载；当VXLAN网络需要与VLAN网络通信时，采用物理交换机做VXLAN GW，实现VXLAN网络主机与VLAN网络主机的通信；采用高端交换机做VXLAN IP GW，实现VXLAN网络与WAN以及Internet的互连。 Host Overlay 方案: ​ 所有终端均采用虚拟交换机作为VTEP节点，VTEP、VXLAN GW、VXLAN IP GW均通过安装在服务器上的软件实现，vSwitch实现VTEP功能，完成VXLAN报文的封装解封装；vFW等实现VXLAN GW功能，实现VXLAN网络与VLAN网络、物理服务器的互通；vRouter作为VXLAN IP GW，实现VXLAN网络与Internet和WAN的互联。在本组网中，由于所有VXLAN报文的封装卸载都通过软件实现，会占用部分服务器资源，当访问量大时，vRouter会成为系统瓶颈。 Hybrid Overlay 方案: ​ 既有物理交换机接入，又有虚拟交换机接入，且软件VTEP和硬件VTEP之间可以基于标准协议互通。上述两种组网方案中，网络Overlay方案与虚拟机相连，需要通过一些特殊的要求或技术实现虚拟机与VTEP的对接，组网不够灵活，但是主机Overlay方案与传统网络互通时，连接也比较复杂，且通过软件实现VXLAN IP GW也会成为整个网络的瓶颈，所以最理想的组网方案应该是一个结合了网络Overlay与主机Overlay两种方案优势的混合Overlay方案。如上图所示它通过vSwitch实现虚拟机的VTEP，通过物理交换机实现物理服务器的VTEP，通过物理交换机实现VXALN GW和VXLAN IP GW；混合式Overlay组网方案对虚拟机和物理服务器都能够很好的兼容，同时通过专业的硬件交换机实现VXLAN IP GW从而承载超大规模的流量转发，是目前应用比较广泛的组网方案。 PS: OpenStack 采用的是第二种方案 ​ 另外IETF在Overlay技术领域有如下三大技术路线正在讨论，为简单起见，只讨论基于IPv4的Overlay相关内容。 1 . VXLAN。 VXLAN是将以太网报文封装在UDP传输层上的一种隧道转发模式，目的UDP端口号为4798；为了使VXLAN充分利用承载网络路由的均衡性，VXLAN通过将原始以太网数据头(MAC、IP、四层端口号等)的HASH值作为UDP的号；采用24比特标识二层网络分段，称为VNI(VXLAN Network Identifier)，类似于VLAN ID作用；未知目的、广播、组播等网络流量均被封装为组播转发，物理网络要求支持任意源组播(ASM)。 2. GRE/NVGRE（Generic Routing Encapsulation，通用路由协议封装）是一种 IP-over-IP 的隧道。 NVGRE是将以太网报文封装在GRE内的一种隧道转发模式；采用24比特标识二层网络分段，称为VSI(Virtual Subnet Identifier)，类似于VLAN ID作用；为了使NVGRE利用承载网络路由的均衡性，NVGRE在GRE扩展字段flow ID，这就要求物理网络能够识别到GRE隧道的扩展信息，并以flow ID进行流量分担；未知目的、广播、组播等网络流量均被封装为组播转发。 3.STT（Stateless Transport Tunneling）。 STT利用了TCP的数据封装形式，但改造了TCP的传输机制，数据传输不遵循TCP状态机，而是全新定义的无状态机制，将TCP各字段意义重新定义，无需三次握手建立TCP连接，因此称为无状态TCP；以太网数据封装在无状态TCP；采用64比特Context ID标识二层网络分段；为了使STT充分利用承载网络路由的均衡性，通过将原始以太网数据头(MAC、IP、四层端口号等)的HASH值作为无状态TCP的源端口号；未知目的、广播、组播等网络流量均被封装为组播转发。 参考: http://www.h3c.com.cn/About_H3C/Company_Publication/IP_Lh/2013/04/Home/Catalog/201309/796466_30008_0.htm]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[pyinstaller使用技巧]]></title>
      <url>%2F2017%2F01%2F22%2Fpyinstaller%E4%BD%BF%E7%94%A8%E6%8A%80%E5%B7%A7%2F</url>
      <content type="text"><![CDATA[​ 不经意间发现了这个工具pyinstaller2.0。它的功能是把python脚本打包成windows的可执行文件，这样就可以方便使用程序了。为了玩一下，于是写了一个图片分类的脚本，按照jpg, gif, png后缀将图片分别存储在各自文件夹中。脚本放在github上了。https://github.com/Luckylau/Useful-Python-Sample/blob/master/useful-tools/classify_Pic.py pythoninstall2.0运行前需要安装pywin32，假如你使用的是python 2.7(64位)，需要在官网 https://sourceforge.net/projects/pywin32/files/pywin32找到对应的版本 我的环境：win 10 python 2.7 (64位) ,pywin32-220.win-amd64-py2.7 打开pyinstall-2.0文件夹 如下图，shift+右键鼠标打开cmd,注意的是文件的路径不能有中文，我之前用的路径是D:\日常资料\日常资料\图片\大雪，会出现编码问题 在cmd上执行,不用理会error报错。 pyinstaller参数有如下选项，我们用的是-F, 后面跟的是要打包的python脚本的位置。 可选的opts有： -F, –onefile 打包成一个exe文件。 -D, –onedir 创建一个目录，包含exe文件，但会依赖很多文件（默认选项）。 -c, –console, –nowindowed 使用控制台，无界面(默认) -w, –windowed, –noconsole 使用窗口，无控制台 完毕之后，会在下图所示位置生成exe文件。 我们在该目录下取得exe文件，执行效果和python脚本是一样的。大功告成~~~~]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[hexo备份小技巧]]></title>
      <url>%2F2017%2F01%2F21%2Fhexo%E5%A4%87%E4%BB%BD%E5%B0%8F%E6%8A%80%E5%B7%A7%2F</url>
      <content type="text"><![CDATA[提交到github上备份: 12345678910111213cd blog/hexo# 初始化仓库git initgit add .git commit -m &quot;init&quot;# 建一个分支git checkout -b hexo# 删除本地的master分支git branch -d master# 添加远程git remote add origin https://github.com/用户名/用户名.github.io.git# 保存git push -u origin hexo 更换环境时: 123456789101112131415#1.安装git(配置git),nodejs;#2.克隆到本地git clone https://github.com/用户名/用户名.github.io.git hexocd hexo git checkout hexo#3.安装各种npm包npm install -g hexo-clinpm installnpm install hexo-deployer-git --save#用于markdown插入图片,首先确认 _config.yml 中有 post_asset_folder:truenpm install https://github.com/CodeFalling/hexo-asset-image --save#4 部署hexo cleanhexo generatehexo deploy]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Python中的struct模块]]></title>
      <url>%2F2017%2F01%2F19%2FPython%E4%B8%AD%E7%9A%84struct%E6%A8%A1%E5%9D%97%2F</url>
      <content type="text"><![CDATA[​ python的struct模块，是在查看RYU控制器Openflow协议的实现源码接触到的。RYU控制器解包和封包就是用struct模块实现的。 ​ 在C语言中，struct结构体里面可以包含不同数据类型，比如int ,char,bool等。但是一旦涉及到网络通信时，传递的是二进制数据流（binary data）。对于二进制字符串，不必担心，但是对于如int，char等基本数据类型，需要有一种机制将这些特定的结构体类型打包成二进制流的字符串然后再在网络传输，同时接收端也需要通过某种机制进行解包还原出原始的结构体数据。 ​ python中的struct模块就提供了这样的机制，该模块的主要作用就是对python基本类型值与用python字符串格式表示的C struct类型间的转化，如下图: 1.简单演示 12345678910111213141516171819import structimport binasciivalues=(2017,'luckylau0',1.19)s=struct.Struct('I9sf')packed_data = s.pack(*values)#打包unpacked_data = s.unpack(packed_data)#解包print 'Original values:', valuesprint 'Format string :', s.formatprint 'Uses :', s.size, 'bytes'print struct.calcsize('I9sf')print 'Packed Value :', binascii.hexlify(packed_data)print 'Unpacked Type :', type(unpacked_data), ' Value:', unpacked_data#输出Original values: (2017, 'luckylau0', 1.19)Format string : I9sfUses : 20 bytes20Packed Value : e10700006c75636b796c617530000000ec51983fUnpacked Type : &lt;type 'tuple'&gt; Value: (2017, 'luckylau0', 1.190000057220459) ​ 代码中，首先定义了一个元组数据，包含int、string、float三种数据类型，然后定义了struct对象，并制定了format‘I8sf’，I 表示int ,8s表示八个字符长度的字符串，f 表示 float。最后通过struct的pack和unpack进行打包和解包。通过输出结果可以发现，value被pack之后，转化为了一段二进制字节串，而unpack可以把该字节串再转换回一个元组，但是值得注意的是对于float的精度发生了改变，这是由一些比如操作系统等客观因素所决定的。 2.字节顺序 ​ 打包的后的字节顺序默认上是由操作系统的决定的，当然struct模块也提供了自定义字节顺序的功能 ​ 例如采用小端存储 s = struct.Struct(‘&lt;I3sf’) 3.利用buffer，使用pack_into和unpack_from方法 12345678910111213141516171819202122import structimport binasciiimport ctypes values1 = (1, 'abc', 2.7)values2 = ('defg',101)s1 = struct.Struct('I3sf')s2 = struct.Struct('4sI') prebuffer = ctypes.create_string_buffer(s1.size+s2.size)print 'Before :',binascii.hexlify(prebuffer)s1.pack_into(prebuffer,0,*values1)s2.pack_into(prebuffer,s1.size,*values2)print 'After pack:',binascii.hexlify(prebuffer)print s1.unpack_from(prebuffer,0)print s2.unpack_from(prebuffer,s1.size)#输出Before : 0000000000000000000000000000000000000000After pack: 0100000061626300cdcc2c406465666765000000(1, 'abc', 2.700000047683716)('defg', 101) ​ 使用二进制打包数据的场景大部分都是对性能要求比较高的使用环境，所以上面提到的pack方法都是对输入数据进行操作后重新创建了一个内存空间用于返回，也就是说我们每次pack都会在内存中分配出相应的内存资源，这有时是一种很大的性能浪费。pack_into() 和 unpack_from()的方法就是对一个已经提前分配好的buffer进行字节的填充，而不会每次都产生一个新对象对字节进行存储。在RYU控制器中就是使用这两种方法。 4.总结： struct 模块 Python的struct库是一个简单的,高效的数据封装\解封装的库。主要包含5个函数: struct.pack(fmt, v1, v2, …): 将V1,V2等值按照对应的fmt(format)进行封装。 struct.unpack(fmt, string): 将string按照fmt的格式解封。 struct.pack_into(fmt, buffer, offset, v1, v2, …): 将V1,V2等值按照对应的fmt(format)封装到buffer中，从初始位置offset开始。 struct.unpack_from(fmt, buffer[offset=0，]): 按照fmt的格式，从offset开始将buffer解封。 struct.calcsize(fmt)： 计算对应的fmt的长度。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[阅读书单(4)]]></title>
      <url>%2F2017%2F01%2F19%2F%E9%98%85%E8%AF%BB%E4%B9%A6%E5%8D%95-4%2F</url>
      <content type="text"><![CDATA[2017年-至今98.《你一年的8760小时》-艾力 99.《牛棚杂忆》-季羡林 100.《愚人的坚持》-稻盛和夫，山中伸弥 101.《异类》-马尔柯姆-格拉德威尔 102.《人类动物园》-德斯蒙德莫里斯 103.《美学漫话》-宗白华 104.《逃不开的经济周期》-拉斯特维德 105.《明治维新六十年》-樱雪丸]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[阅读书单(3)]]></title>
      <url>%2F2017%2F01%2F19%2F%E9%98%85%E8%AF%BB%E4%B9%A6%E5%8D%95-3%2F</url>
      <content type="text"><![CDATA[2015年-2016年（35本书）2015年（4本书） 63.《黑客与画家》-Paul Graham 64.《文明之光》-吴军 65.《向死而生》-李开复 66.《大学之路（上）》-吴军 2016年（31本书） 67.《硅谷之谜》-吴军 68.《时间的针脚》-玛利亚杜埃尼亚斯 69.《动物庄园》-奥威尔 70.《绝望锻炼了我：朴槿惠自传》-朴槿惠 71.《解忧杂货店》-东野圭吾 72.《激荡三十年上》-吴晓波 73.《疑问集》-聂鲁达 74.《硅谷钢铁侠：埃隆·马斯克的冒险人生》-阿什利·范斯 75.《鱼羊野史第一卷》-高晓松 76.《你一定爱读的极简欧洲史》-约翰·赫斯特 77.《这么慢,那么美》-罗敷 78.《一个人的朝圣》-蕾秋·乔伊斯 79.《野火集：三十周年纪念版》-龙应台 80.《我们仨》-杨绛 81.《人间失格》-太宰治 82.《在绝望中寻找希望》-俞敏洪 83.《当尼采哭泣》-欧文 D.亚隆 84.《念完哈佛念阿弥陀佛》-陈宇廷 85.《你今天真好看》-莉兹克里莫 86.《我们生活在巨大差异里》-余华 87.《梦里花落知多少》-三毛 88.《纯真博物馆》-奥尔罕帕慕克 89.《岛上书店》-加布瑞埃拉泽文 90.《我与地坛》-史铁生 91.《史玉柱自述：我的营销心得》-史玉柱 92.《飞鸟集》-泰戈尔 93.《我可以咬你一口吗？》-利兹克利莫 94.《末日巨塔-基地组织与911之路》-劳伦斯赖特 95.《菊与刀:日本文化类型》-鲁思本尼迪克特 96.《小王子》-安托万德圣埃克苏佩里 97.《爱你就像爱生命》-王小波]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[阅读书单(2)]]></title>
      <url>%2F2017%2F01%2F19%2F%E9%98%85%E8%AF%BB%E4%B9%A6%E5%8D%95-2%2F</url>
      <content type="text"><![CDATA[2012年-2014年（37本书）2012年（7本书） 26.《爱的艺术》-艾弗洛姆 27.《平凡的世界》-路遥 28.《人生课》-张岱年 29.《世间最美丽的情郎：仓央嘉措的情与诗》-王臣 30.《追风筝的人》-(美国）胡赛尼 31.《纳兰词》-纳兰性德 32.《阿德勒谈灵魂与情感》-阿尔弗雷德阿德勒 2013年（13本书） 33.《促销的本质》-山姆沃尔顿 34.《历史是个什么玩意》-袁腾飞 35.《世界如此险恶，你要内心强大2》-石勇 36.《少有人走的路1》-M·斯科特·派克 37.《世界如此险恶，你要内心强大1》-石勇 38.《明朝那些事儿》-当年明月 39.《天才在左疯子在右》-高铭 40.《哲学与人生I》-傅佩荣 41.《哲学与人生II》-傅佩荣 42.《乌合之众》（法译本）-[法]古斯塔夫·勒庞 43.《万历十五年（增订纪念本）》-[美]黄仁宇 44.《沉默的大多数》-王小波 45.《自控力》-凯利·麦格尼格尔 2014年（17本书） 46.《七里香》，《无怨的青春》，《时光九篇》，《边缘光影》，《迷途诗册》，《我折叠着我的爱》-席慕容 47.《蒙田随笔》-蒙田（上海书店出版社） 48.《读书与做人》-季羡林 49.《男人来自火星，女人来自金星1》-约翰格雷 50.《男人来自火星，女人来自金星2》-约翰格雷 51.《超越自卑》-阿尔弗雷德阿德勒 52.《苏菲的世界》-乔斯坦贾德 53.《德意志的另一行泪》-朱维毅 54.《浪潮之巅》-吴军 55.《如果在冬夜，一个旅人》-[意大利] 伊塔洛·卡尔维诺 56.《审美与人的自由》-刘晓波 57.《撒哈拉的故事》-三毛 58.《文明之光》-吴军 59.《悉达多》-[德]赫尔曼黑塞 60.《呼兰河传》-萧红 61.《月亮与六便士》-毛姆 62.《人类的群星闪耀时》-斯蒂芬茨威格]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[阅读书单]]></title>
      <url>%2F2017%2F01%2F19%2F%E9%98%85%E8%AF%BB%E4%B9%A6%E5%8D%95%2F</url>
      <content type="text"><![CDATA[2009年-2011年（25本书）1.《谈美》-朱光潜 2.《安娜·卡列尼娜》（上下册）-（俄罗斯）托尔斯泰 3.《遇见未知的自己》- 张德芬 4.《人生若只如初见古典诗词的美丽与哀愁》- 安意如 5.《宋词三百首》- 上疆村民选编 6.《世界因你不同——李开复自传》- 李开复 范海涛 7.《思无邪：追绎前生的记忆》-安意如 8.《看张·爱玲画语》-安意如 9.《林肯传 》-戴尔·卡耐基 10.《富豪发家史》-子志编著 11.《水知道答案》-〔日〕江本胜 12.《彼得大帝》-帕甫连科 13.《活着就是为了改变世界》-杰弗里·扬,威廉西蒙 14.《我是沃兹：一段硅谷和苹果的悲情罗曼史》-斯蒂夫沃兹尼亚 15.《美国通史(上)》 16.《美国通史(下)》 17.《爱情诗集》- 文爱艺 18.《麦田里的守望者》-J.D塞林格 19.《批评官员的尺度：《纽约时报》诉警察局长沙利文案》-安东尼 20.《你是那人间的四月天》-林徽因 21.《汪国真经典诗文》-汪国真 22.《中国人的品格》-罗家伦 23.《蒙田随笔》-蒙田 24.《汪国真精选集》 25.《巨流河》-齐邦媛]]></content>
    </entry>

    
  
  
</search>
